<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Underwater Descent + Water Shader</title>
  <style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
import { Water } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/objects/Water2.js';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/RenderPass.js';
import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/ShaderPass.js';

// -- Scene, Fog, Renderer
const scene = new THREE.Scene();
const waterColor = 0x1e3f66;
scene.fog = new THREE.FogExp2(waterColor, 0.03);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(waterColor);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.append(renderer.domElement);

// -- Camera
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 5, 20);

// -- Light
const dl = new THREE.DirectionalLight(0xffffff, 1.2);
dl.position.set(0,50,0);
scene.add(dl);

// -- Water Surface
const waterGeom = new THREE.PlaneGeometry(100, 100);
const water = new Water(waterGeom, {
  color: waterColor,
  scale: 4,
  flowDirection: new THREE.Vector2(1,1),
  textureWidth: 1024, textureHeight: 1024
});
water.rotation.x = -Math.PI / 2;
water.position.y = 5;
scene.add(water);  // geometry only :contentReference[oaicite:8]{index=8}

// -- Post-processing (blue tint + distortion)
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const underwaterShader = {
  uniforms: { tDiffuse: { value: null }, time: { value: 0 }, intensity: { value: 0.1 } },
  vertexShader: `
    varying vec2 vUv;
    void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.); }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse; uniform float time, intensity;
    varying vec2 vUv;
    void main(){
      vec2 uv = vUv;
      uv.x += (sin(uv.y * 50.0 + time * 5.0) * intensity);
      vec4 c = texture2D(tDiffuse, uv);
      c.rgb = mix(c.rgb, vec3(0.0,0.1,0.3), 0.2);
      gl_FragColor = c;
    }
  `
};
const uwPass = new ShaderPass(underwaterShader);
composer.addPass(uwPass);

// -- Resize handler
window.addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  composer.setSize(innerWidth, innerHeight);
});

// -- Animation: camera descent + water update
let startTime = performance.now();
function tick(){
  requestAnimationFrame(tick);
  let t = (performance.now() - startTime) / 8000;
  let ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
  camera.position.y = 5 + ( -45 - 5), 
                        camera.position.y = 5 + (-45 - 5)*ease;
  camera.lookAt(0, camera.position.y, 0);
  water.material.uniforms['time'].value += 1/60;
  uwPass.uniforms['time'].value = (performance.now() - startTime)/1000;
  composer.render();
}
tick();
</script>
</body>
</html>

